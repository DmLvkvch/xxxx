привет

круто, что
- все собиралось под вин и лин
- требование про единственность интерфейсов выполнено
- плагины подключались из заданной папки автоматом
- уже появились виджеты
- есть меню с настройками и Ctrl+Q

с твоего позволения, я внес кое-какие изменения в проект, чтобы уже более менее зафиксировать его структуру. теперь там
- интерфейсы и плагины собираются в библиотеки
- изменилась папка, где mainwindow ищет плагины (не надо плагины раскладывать по отдельным папкам)
- посмотри реализацию setUpPlugins. до этого она у тебя очень хитро работала (но тем не менее рботала)

я твои классы по отображению постарался не трогать. мы их не обсуждали в прошлый раз, задания по ним не было, но тем не менее эти замечания следует учесть на будущее
- нельзя оборачивать QWidget в QSharedPointer (погугли этот момент. при таком подходе у виджета меняется parent)!!! сейчас у тебя из-за этого падает приложение при закрытии
(надо переписать логику создания и хранения виджетов в mainwindow)
- зачем ты logs включил в интерфейсы? это же сущность, которая лишь на отображение влияет. интерфейсы нужны как общий элемент для плагинов и гуи
- делать больше проверок (но разумных. не надо проверять if (this == nullptr), а то я иногда вижу такое в коде коллег). например, когда ты ищешь плагины в папке, сперва надо проверить, а существует ли она вообще, чтобы можно было выдать ошибку. указатели проверять на нулл при обращении. в том числе и sharedpointer
- зачем qdebug подключать в хэдере?)
- все текстовые значения, которые отображаются на вьюшке должны быть написаны по-русски. но в коде при этом обернуты в tr()
- у плагинов есть create, но нет delete. надо сделать, чтобы при закрытии, корректно останавливать, выгружать и удалять их
- скобочки {} писать каждую на отдельной строке и для всех операторов (даже если это необязательно по стандарту)
например 
void func_do_smth(void* pointer)
{
	if (pointer == nullptr)
	{
		return;
	}
}
это вкусовщина, но так читать удобнее
- зачем использовать #include <iostream>, когда есть qdebug? раз уж мы на qt пишем, лучше использовать qt-шные сущности
- при загрузке плагина в случае
	else
        {
            qDebug() << "Error " << lib.errorString();
        }
зачем дальше пытаться что-то делать? сразу return в таких случаях
это тоже в некотором роде вкусовщина, но я предпочитаю использовать концепцию early exit (можешь почитать https://medium.com/better-programming/are-early-returns-any-good-eed4b4d03866). это не панацея. как и все в программировании, ее надо использовать разумно
- коннект делать по-новому (https://wiki.qt.io/New_Signal_Slot_Syntax/ru). т.е. вместо
QObject::connect(_openSettingsButton.data(), SIGNAL(clicked()), this, SLOT(handleOpenSettings()));
писать
connect(_openSettingsButton.data(), &QPushButton::clicked,
            this, &PluginWidget::handleOpenSettings);
это полезно, когда в сигнале/слоте несколько параметров, а также при изменении сигнатуры сигнала или слота, ты получишь ошибку компиляции
- кнопка отмены в настройках - лишняя. есть крестик
- (?) это на будущее. я пока сам не знаю, как лучше: интерфейс возвращает QIcon, а эти сущности требуют включения в проект сборки либы gui. возможно вместо QIcon лучше возвращать путь до иконки. а уже иконку подгружать будет лаунчер
сейчас не очень хорошо получается, потому что плагин включает в себя gui

теперь следующий этап
- причесать вьюшку с учетом замечаний
- начать реализовывать взаимодействие с Виртусом (он же Фортис)
